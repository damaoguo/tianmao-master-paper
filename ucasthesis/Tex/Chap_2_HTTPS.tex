\chapter{相关研究及概述}\label{chap:https}

\section{TLS综述}
TLS/SSL的功能实现主要是依赖于三类基本的算法：非对称加密、对称加密以及散列算法。非对称加密主要用于密钥协商的阶段，非对称加密和解密的过程比较困难，因为这涉及到求解最大素数。对称加密重要用于密钥协商好之后的加密通信，这个密钥主要是client发起的（ 即客户端产生的Pre-master，于是，客户端和服务端之间的通信是一对一的加密通信），在这个过程中，多次使用了hash算法，hash算法将不同长度的信息计算为等长的信息，这个过程是不可逆的，目的是为了验证数据的完整性。

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.80\textwidth]{ssl}
	\bicaption{SSL主要功能 }{}
	\label{fig:SSL}
\end{figure}

\subsection{TLS简介}
HTTPS (Secure Hypertext Transfer Protocol)安全超文本传输协议，是一个安全通信通道，它基于HTTP开发用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版,是使用TLS/SSL加密的HTTP协议。

HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。

TLS/SSL全称安全传输层协议Transport Layer Security, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.60\textwidth]{http_and_https}
	\bicaption{http和https的关系 }{}
	\label{fig:http_and_https}
\end{figure}

\subsection{SSL版本}
2018年3月，TLS1.3协议正式批准问世，成为客户端和服务器之间通过HTTPS连接建立加密通信的最新标准。TLS1.3既能提高互联网用户的访问速度，又能增强安全性，大大提升HTTPS连接的速度性能。Chrome63已经支持TLS1.3，目前为止仅针对Gmail推出了TLS1.3，在2018年，谷歌将把TLS 1.3推到整个网络，使加密通信更快，更安全。Mozilla是在Firefox49开发版开始支持TLS1.3，Firefox52是首个面向所有用户提供TLS 1.3支持的稳定版。

TLS1.3与TLS1.2及更早版本的区别:
在配置正常的情况下，TLS1.2会很安全。但TLS1.2具有很强的可配置性，因此一些有安全漏洞的站点，为兼容老版本的浏览器没有关闭一些旧的属性。TLS1.3信奉“少即是多”哲学，取消了对一些老旧而衰弱的加密方式的支持，TLS1.2中原有的大量特性都被删除了。这些特性包括：
\begin{itemize}
	\item RSA密钥传输：不支持前向安全性
	\item CBC模式密码：易受BEAST和Lucky 13攻击
	\item RC4流密码：在HTTPS中使用并不安全
	\item SHA-1哈希函数：建议使用SHA-2取而代之
	\item 任意Diffie-Hellman组：CVE-2016-0701漏洞
	\item 输出密码：易受FREAK和LogJam攻击
\end{itemize}

TLS1.3版本是对规范的重大修改，一些工作方式也非常不同：
\begin{itemize}
	\item 有一些新的密码套件仅在TLS1.3下工作，一些旧的密码套件无法再TLS1.3上使用。
	\item 新的密码套件定义方式不同，且并没有详细规定证书类型(如RSA,DSA,ECDSA)或者密钥交换机制(如DHE或者ECHDE)。这对密码套件的配置有暗示作用。
	\item 客户端在客户问候消息(client hello)中提供了一个“key\_share”,这会对“组”配置产生影响。
	\item 直到主握手完成以后，会话才会建立。在握手结束和会话建立之间可能会有一个间隙(理论上，会话可能根本不会建立)，并可能对会话恢复代码产生影响。
	\item 在TLS1.3版本中，重新磋商是不可能的。
	\item 现在大部分握手都会被加密。
	\item 更多类型的消息现在可以有扩展(这对定制扩展API和证书透明系统有影响)。
	\item 在TLS1.3连接中不再允许使用DSA证书。
\end{itemize}


\subsection{SSL之扩展(extension)}
\subsubsection{server name extension(SNI)}
早期的SSL2.0根据经典的公钥基础设施PKI(Public Key Infrastructure)设计，它默认认为：一台服务器(或者说一个IP)只会提供一个服务，所以在SSL握手时，服务器端可以确信客户端申请的是哪张证书。

但是让人万万没有想到的是，虚拟主机大力发展起来了，这就造成了一个IP会对应多个域名的情况。有一些解决办法，例如申请通配域名证书，对所有同一顶级域名下的二级子域名(*.yourdomain.com)都可以认证，但如果你还有一个yourdomain.net的域名，那就不行了。如果在同一个IP上配置多个HTTPS主机，会出现一个很普遍的问题：不论浏览器请求哪个主机，都只会收到默认主机www.example.com的证书。这是由SSL协议引起的——先建立SSL连接，再发送HTTP请求，所以nginx建立SSL连接时不知道所请求主机的名字，因此，它只会返回默认主机的证书。最古老的也是最稳定的解决方法就是每个HTTPS主机使用不同的IP地址，在同一个IP上，使用SNI配置多个HTTPS主机。

在HTTP协议中，请求的域名作为主机头(Host)放在HTTP Header中，所以服务器端知道应该把请求引向哪个域名，但是早期的SSL做不到这一点，因为在SSL握手的过程中，根本不会有Host的信息，所以服务器端通常返回的是配置中的第一个可用证书。因而一些较老的环境，可能会产生多域名分别配好了证书，但返回的始终是同一个。既然问题的原因是在SSL握手时缺少主机头信息，那么补上就是了，即添加扩展。

SNI(Server Name Indication)定义在RFC 4366，是一项用于改善SSL/TLS的技术，在SSL3.0/TLS1.0中被启用。它允许客户端在发起SSL握手请求时(具体说来，是客户端发出SSL请求中的ClientHello阶段)，就提交请求的Host信息，使得服务器能够切换到正确的域并返回相应的证书。





\section{TLS安全机制}
\subsection{HTTPS连接建立的过程}
证书颁发机构的英文全称是Certificate Authority，一般简称为CA。证书颁发机构是采用PKI（Public Key Infrastructure）公开密钥基础架构技术，专门提供网络身份认证服务，负责签发和管理数字证书，且具有权威性和公正性的第三方信任机构。它的作用就像我们现实生活中颁发证件的公司，如护照办理机构。证书颁发机构 (CA) 是一个向单位、个人等颁发证书的可信实体。CA 受理证书申请，根据该 CA 的策略验证申请人的信息，然后使用它的私钥把其数字签名应用于证书。然后，CA 将该证书颁发给该证书的主体。由浏览器联盟维护着CA根证书列表，大型机构或政府机构可能拥有自己的CA.

一个完整的 HTTPS 链接的建立大概需要以下四步：

第一步：DNS 查询：浏览器在建立链接之前，需要将域名转换为互联网 IP 地址。一般默认是由你的 ISP DNS提供解析。ISP 通常都会有缓存的，一般来说花费在这部分的时间很少。

第二步：TCP 握手( 1 RTT)：和服务器建立 TCP 连接，客户端向服务器发送 SYN 包，服务端返回确认的 ACK 包，这会花费一个往返(1 RTT)

第三步：TLS 握手(2 RTT)：该部分客户端会和服务器交换密钥，同时设置加密链接，对于 TLS 1.2 或者更早的版本，这步需要 2 个 RTT

第四步：建立 HTTP 连接(1 RTT)：一旦 TLS 连接建立，浏览器就会通过该连接发送加密过的 HTTP 请求。

我们假设 DNS 的查询时间忽略不计，那么从开始到建立一个完整的 HTTPS 连接大概一共需要 4 个RTT，如果是浏览刚刚已经访问过的站点的话，通过 TLS 的会话恢复机制，第三步 TLS 握手能够从 2 RTT变为 1 RTT.

\subsection{HTTPS握手过程}
1.client hello：客户端首先主动发起请求，以明文传输请求信息：包括版本信息，加密套件候选列表，压缩算法候选列表，随机数，扩展字段信息。相关信息如下：
版本信息：当前基本已经不再使用TLSv1的版本；客户端的加密套件cipher suites列表：每个加密套件对应着四个主要的功能组合---认证算法AU（ 身份验证）、密钥交换算法keyExchange密钥协商、对称加密算法Enc信息加密、和信息摘要Mac信息完整性校验。支持的压缩算法列表用于后续的压缩计算，随机数用于后续的密钥生成。扩展字段包含的信息比较丰富，是我们识别过程中应该重点关注的对象，比如extension中的server name是SNI，我们可以提取出主机名称。注意传输过程是明文传输，所以对抓包非常有作用。

2.server hello + server certificate + server hello done：server hello服务器返回协商的信息，主要和client hello比较类似，区别在于服务器端对于cipher suite进行了选择，压缩算法进行了选择；server certificate服务器端配置对应的证书链，用于身份验证和密钥交换；server hello done，通知客户端server hello信息发送结束。这个过程也是通过明文进行传输的，我们通过抓包，可以获取到加密套件cipher suite.server hello done通知客户端srver hello信息发送结束。

3.客户端验证证书的合法性，证书是第三方机构提供的，在客户端：如浏览器中保存了相关的证书信息，如果证书通过才会进行后续的通信，否则根据错误的信息提示操作。合法性的检验包括：证书链的可信性，证书是否被吊销，有效期以及域名。

4.client key exchange + change cipher spec = encrypted handshake messege,client key exchange 合法性验证通过后客户端计算随机产生Pre-master，使用公钥加密，发送给服务器，此时此刻，客户端实际已经计算出协商密钥了，用到的信息是之前产生的。通过enc\_key=Fuc(random\_C,random\_S,Pre\-master)计算协商密钥，change\_cipher\_spec客户端通知服务器后续的通信都是通过协商密钥对称加密的方式进行。encrypted handshake messge,结合之前使用到的所有通信参数的hash值与其他的相关信息生成一段数据，采用协商密钥session secret与算法进行加密，然后发送服务器用于数据与握手验证。

5.change cipher spec + encrypted handshake messege，服务器用私钥解密加密的Pre-master，基于之前的random\_C和random\_S计算得到协商密钥：enc\_key=Fuc(random\_C,random\_S,Pre-master),计算之前所有接受信息的hash值，然后解密客户端发送的encrypted handshake messege，验证数据和密钥的正确性。之后，change cipher spec，验证通过以后，服务器也要发送change cipher spec以告知客户端后期的通信都是采用协商的密钥与算法进行通信。然后是encrypted handshake messege阶段，服务器也将结合当前通信参数信息生成一段数据并采用协商密钥session secret与算法加密发送给客户端。

6.握手结束：客户端计算接收到的数据的hash值，采用协商好的密钥解密服务器发送过来的encrypted handshake messege验证服务器发送的数据和密钥，验证通过则握手结束。

7.加密通信，开始使用协商的密钥与算法进行加密通信。


\subsection{SSL加密计算过程}
SSL加密计算过程为：

\begin{figure}[!htbp]
	\centering
	\includegraphics[width=0.60\textwidth]{ssl_encrypted}
	\bicaption{SSL加密计算 }{}
	\label{fig:SSL_encrypted}
\end{figure}

Pre-master由客户端产生，采用RSA或Diffie-Hellman等加密算法生成，Pre-master结合random client和random server两个随机数通过PseudoRandomFunction(PRF)计算得到Master secret，Master secret结合两个随机数进行迭代计算得到Key material.


\section{相关机器学习/深度学习算法}
\subsection{随机森林}
\subsection{支持向量机}
\subsection{深度学习算法}
\subsection{迁移学习方法}
\subsection{增量学习方法}


\section{小结}
通过对TLS/SSL协议的研究，可以发现，在HTTPS通信过程中，能够暴露出可以用于流量分析的特征。